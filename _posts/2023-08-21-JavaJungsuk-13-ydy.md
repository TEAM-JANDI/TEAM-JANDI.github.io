---
layout: post
title: "[13챕터] 메모리 가시성, 메모리 장벽"
subtitle: 자바의 정석 스터디 21회차
categories: Java
tags: [Java, Thread, 자바의정석, 메모리 가시성, 메모리 장벽]
published: false
---


## 메모리 가시성(Memory Visibility) 
한 쓰레드에서 변경한 데이터의 값이 다른 쓰레드에서 제대로 반영되는지 여부.

### 메모리 가시성 문제 발생의 원인
(정확히는 메모리 가시성이 보장되지 않을 때 발생할 수 있는 문제)

1. 각각의 코어가 각자의 캐시를 가지고 있다.  
2. 컴파일러의 최적화로 인해, 프로그램의 속도를 높이기 위해 캐시를 활용하게 된다.  

컴파일러의 최적화로 인해 CPU는 메인메모리가 아닌 캐시를 활용하도록 동작하는데, 이로 인해 멀티코어 환경에서 코어의 캐시와 메인메모리의 데이터가 서로 일치하지 않는 경우가 발생한다.  
가령 A쓰레드가 어떤 데이터의 값을 변경한 것이 A쓰레드 코어의 캐시까지만 반영되고 아직 메인메모리에 반영되지 않은 상황에서, B쓰레드가 메인메모리에서 (혹은 본인 CPU의 캐시에서) 해당 데이터를 읽음으로써, 결과적으로 A쓰레드와 B쓰레드가 각자 다른 값의 데이터로 작업하게되는 상황이 발생할 수 있다.

### 가시성을 보장하려면?
변경된 데이터를 메인 메모리에 바로 반영하고, 데이터를 캐시가 아닌 메인메모리에서 읽음으로써 가시성을 보장할 수 있다.  
java에서는 volatile, synchronized, atomic 등의 키워드가 있다.  



## 메모리 장벽(Memory Barrier, Memory Fence) 
CPU나 컴파일러에게 메모리 장벽 명령문 전/후의 연산 순서가 지켜지도록 강제한다. 즉, 메모리 장벽 명령문 이전의 연산이 메모리 장벽 명령문 이후의 연산보다 먼저 실행되도록 한다.  
메모리 장벽을 세우면 코어가 해당 명령어를 수행할 떄 이전까지의 작업을 모두 메인메모리에 반영한다. 즉, 메인메모리에 flush 하게 되는 것이므로 메모리 가시성 또한 이뤄지게 된다.  
또한 컴파일러가 재배치 작업을 수행할 때 메모리 장벽 내의 코드는 재배치하지 않는다.  
로우 레벨 언어로 하드웨어 개념이다. 높은 레벨의 언어에서는 뮤텍스와 세마포어를 이용해 적용할 수 있다.

### 주의점
신경써야 할 점은, 메인메모리에 값을 반영하게 했다면 이를 조회하는 작업 또한 캐시가 아닌 메인메모리에서 값을 읽어오도록 조치해야 한다는 것이다. 기껏 비용 들여서 메인메모리에 넣어놓고 캐시에서 읽지 않도록.

### 메모리 장벽을 만들려면?
메모리 장벽이 필요한 부분에 lock을 걸어주면 된다.   
synchronized 키워드를 사용할 수 있겠다. synchronized 블럭을 지날 때, 메모리 장벽을 통과하는 것이다.  

### 명령어 재배치란?
컴파일러의 최적화로 인해 명령어 재배치가 이뤄진다. 즉, 성능을 향상시키려고 코드의 순서가 달라질 수 있다. 아래와 같은 코드가 있다고 치자.

boolean flag = false;  
int num = 0;  
flag = true;  
num = 10;  

사람은 'flag가 true로 바뀐 후 num의 값이 10으로 바뀌도록 작성했구나.'다고 생각할 수 있다. 그러나 컴파일러 입장에서는 flag와 num 간에 종속적인 부분이 없기 때문에 제멋대로 저 코드를 재배치해버릴 수도 있는 것이다.

boolean flag = false;  
int num = 0;  
num = 10;  
flag = true;  

이렇게 말이다. 컴파일러 입장에서는 num이 먼저 수정되나 flag가 먼저 수정되나 결과가 똑같거든.   

다만 앞서 말했듯 메모리 장벽 내의 코드는 명령어 재배치 대상에서 제외된다. flag = true; 와 num = 10;의 수행 순서를 보장하고 싶으면 synchronized 블럭에 해당 코드를 넣을 수 있겠다. 


## Java에서의 관련 키워드
### volatile
가시성 보장.  
변수에 사용.  
읽기/쓰기 작업이 캐시가 아닌 메인메모리에서 처리된다. 즉, 지역적이 아닌 전역적으로 처리함으로써 가시성을 보장한다.

**주의점**  
원자성을 보장하지는 않는다. (long, double 등의 변수에 한해서는 가능)  
volatile 데이터에 접근하고 나면 해당 데이터 외에도 모든 dirtyBlock들이 메인메모리로 flush 되므로 사이드이펙트를 고려해야 한다.
연산의 단일성을 보장하지 않는다. 가령 count++ 같은 코드는 하나의 라인이지만 실제로는 값을 읽고/수정하는 과정을 거친다. 만약 두 쓰레드가 동시에 count++을 수행한다면, 값이 1만 증가하는 동시성 문제가 발생할 수 있다.  
캐시의 데이터를 매번 메인메모리에 반영하므로 비용이 크기 때문에 필요한 때에만 반영하도록 할 필요가 있다. (-> 메모리 장벽)

**사용하기 적절한 경우**  
해당 변수의 값을 단순히 변경하는 쓰레드가 하나만 존재하는 경우.  
해당 변수를 사용하는 동안 lock을 걸 필요가 없는 경우.

### synchronized
동기화 보장(가시성, 원자성)  
메서드, 코드 블럭에 사용.  
synchronized 키워드를 사용한 코드 블럭은 lock이 걸려 한 번에 하나의 쓰레드만 접근할 수 있으며, 블럭을 벗어날 때 캐시에서 flush 되지 않은 데이터를 모두 메인메모리에 flush한다.    

### atomic
동기화 보장(가시성, 원자성)  
변수에 사용.  
volatile과 다르게 연산의 단일성을 보장한다.  
synchronized와 다르게 lock을 걸지 않는다.  
CAS 알고리즘을 통해 synchronized와 다르게 lock을 걸지 않는다.

---
출처
https://blog.naver.com/jjoommnn/130037479493  
https://kjhoon0330.tistory.com/entry/Java-%EB%8F%99%EA%B8%B0%ED%99%94-synchronized%EC%99%80-volatile-Atomic-Class%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC  
https://aeopp.github.io/2020-07-30-memory_fence_and_memory_order/  
https://hbase.tistory.com/317  
https://yoojin99.github.io/cs/Memory-Barrier/  
