---
layout: post
title: "[13챕터] 쓰레드 동기화 방법 분류"
subtitle: 자바의 정석 스터디 22회차
categories: Java
tags: [java, 자바의정석, 쓰레드, 동기화]
---

## JAVA의 연산
JVM 환경에서 연산에 사용되는 메모리 흐름을 설명하면 대략 아래와 같다.

1. JVM(CPU)는 작업을 시작하기 위해 필요한 데이터를 RAM에서 읽어들여서 CPU Cache Memory에 복제한다.
2. 작업을 처리한 뒤, 처리된 데이터는 CPU Cache Memory에 저장된다.
3. JVM은 캐시 메모리의 데이터를 RAM에 덮어 씌우는 RAM 쓰기 작업을 수행한다. 


이 때, 코어가 여러개인 CPU라면 코어별로 각자의 캐시 메모리를 갖게 된다.

그런데 작업 진행 시점에 따라 하나의 데이터에 대한 각 코어별 캐시 메모리에 저장된 값이 달라질 수 있는데,

그럴 때 아래와 같은 문제가 발생할 수 있다.


## 메모리 가시성 문제

하나의 스레드에서 작업한 변경 내용이 다른 스레드에서 인식되지 않는 상황을 의미한다.


예시)

1. 메인 스레드에 finish 라는 변수가 있고, A 라는 스레드는 finish가 false일 동안 루프를 도는 프로그램이 있다.

2. 메인 스레드에서 모든 작업을 끝낸 뒤 finish를 true로 바꾸면 A스레드가 멈출 것 같지만, A스레드는 영원히 멈추지 않는다.

A 스레드가 참조하는 캐시 메모리의 finish는 계속 false이기 때문이다.

(메인 스레드와 A 스레드는 각각 다른 코어가 배정되었다는 가정이다)


## 메모리 동시 접근 문제

공유 자원에 여러 스레드가 접근하여 읽고 쓰는 상황에서 데이터의 일관성을 유지할 수 없는 문제.

예를 들면 아래와 같은 문제들이 발생한다.

- 경쟁 조건 문제 (Race Condition)

한 스레드가 데이터를 변경하는 동안 다른 스레드가 변경되기 전의 데이터를 읽는 상황

- 데이터 일관성 문제

동시에 같은 변수를 변경하여 결과를 예상할 수 없거나, 작업이 더 늦게 끝난 스레드의 값으로 덮어씌워지는 상황


## 동기화

이러한 문제를 해결하기 위해 다양한 동기화 방법들이 탄생 했다.

자바는 대표적으로 세 가지의 방법을 제공한다.


# 1. volatile 키워드 (가시성 문제만 해결)

- 변수를 CPU Cache Memory가 아닌 RAM (메인메모리)에 저장하겠다고 명시하는 키워드

- 변수의 값을 Read할 때마다 메인 메모리에서 읽어온다.

- 변수의 값을 Write할 때마다 메인 메모리까지 작성한다.


주의할 점은, 여러 스레드에서 write 하는 상황이라면 완벽하게 안전을 보장하지 못한다.

즉, 위에서 설명한 동시 접근 문제의 경쟁 조건 이슈를 해결하지 못한다는 의미이다. (변수를 동시에 읽어간 뒤 다른 값으로 수정하는 경우)
따라서 하나의 스레드에서 write하고 다른 스레드들은 read만 하는 변수에 대해 적용하는 것이 좋다.


# 2. synchronized 키워드

스레드 간의 상호 배제를 통해 공유 자원에 대한 동시 접근을 막는다.

즉, 하나의 공유 자원은 한 번에 하나의 스레드만 접근할 수 있도록 하는 것이다.



클래스/메소드/블록 단위로 적용할 수 있으며, 가장 처음 공유 자원에 접근한 스레드가 작업을 끝낼 때까지 자원에 lock을 걸어서

다른 스레드에서의 접근을 차단한다. 이러한 방법으로 가시성 문제와 동시 접근 문제를 해결할 수 있다.


단점은

1. 과도하게 사용할 경우 성능 이슈가 발생할 수 있다.

- 스레드가 락을 획득하거나 해제할 때 오버헤드가 발생하여 과도하게 사용할 경우 성능이 저하된다.

2. 데드락 발생 가능

- synchronized 구간에 진입하려했으나 다른 스레드가 락을 획득하여 사용 중인 경우, 진입하려 했던 스레드는 락이 해제될 때까지 대기 상태에 들어가게 된다. 이 때, 서로 다른 스레드가 서로에게 필요한 자원의 락을 갖고 있어 영원히 락이 해제될 수 없는 상황을 데드락이라고 한다.



# 3. atomic 변수들 (AtomicInteger 등)

atomic은 한국어로 원자라는 뜻 이다.

원자성은 완료되거나, 완료되지 않거나 두 가지의 상태만 갖는 성격이고

스레드 동기화에서 말하는 원자성이란 결국 연산의 원자성, 단일 연산을 말한다.

원자성을 띄는 연산이 되려면 어떠한 연산을 수행하는 동안 다른 스레드의 간섭을 받지 않고 완전히 실행되어야 하고, 간섭을 받았다면 작업이 완료되지 않아야 한다.


atomic 변수는 이러한 원자성을 보장하는 변수이다.



예를 들면

i++;

라는 연산은 프로그래밍 언어로 보면 단일 연산처럼 보일 수 있지만

실제 연산 과정을 살펴보면



1. 메인메모리에서 값을 읽어온다 (Read)

2. 값을 수정한다 (Modify)

3. 메인메모리에 값을 덮어 씌운다 (Write)



최소 3가지의 연산 과정을 거친다.

따라서 우리가 보기에 간단한 연산이라도 컴퓨터 입장에서는 단일 연산이 아니다.



그러면 atomic 변수는 어떻게 원자성을 보장해줄까.

바로 CAS 알고리즘 (Compare And Swap)을 사용한다.



CAS 알고리즘이란 현재 CacheMemory 와 MainMemory 에 저장된 값을 비교하여, 일치하는 경우 새로운 값으로 교체하고, 일치하지 않을 경우 교체 실패 처리 되어, 연산을 다시 시도 하는 방식이다. 말 그대로, 비교하고(Compare) 교체하는(Swap) 알고리즘이다.



아래는 AtomicInteger 내부 코드를 대략적으로 표현한 코드이다. (ChatGPT한테 시켰다.)

```java 
public class AtomicInteger {
private volatile int value;

    public AtomicInteger(int initialValue) {
        this.value = initialValue;
    }

    public int incrementAndGet() {
        while (true) {
            int current = value;
            int next = current + 1;
            if (compareAndSet(current, next)) {
                return next;
            }
        }
    }

    public boolean compareAndSet(int expect, int update) {
        if (value == expect) {
            value = update;
            return true;
        }
        return false;
    }
}
```

보면 내부 int 변수가 volatile로 되어있는데, 실제 자바 코드에서도 volatile 변수로 사용한다.



1. volatile(메인메모리에서 읽어온) 변수를 읽어온 다음 캐시 메모리에 저장

2. 업데이트 될 값을 새로운 변수에 저장

3. volatile 변수와 캐시 메모리의 변수를 비교하여 같다면 volatile 변수를 업데이트 될 값으로 교체한다.

  - 만약 비교하여 다르다면 반복문을 돌며 성공할 때까지 연산을 다시 시도한다.



위와 같은 동작 원리로 lock을 잡지 않고 가시성 문제와 동시 접근 문제를 해결하는 것이 atomic 변수이다.


lock을 잡지 않기 때문에 다른 스레드를 대기 상태로 보내는 blocking 방식의 synchronized과 반대로 non-blocking 방식의 동기화 테크닉이기도 하며, synchronized 방식에서 발생할 수 있는 성능 이슈를 어느정도 보완해줄 수 있다.



하지만 복잡한 연산에는 어울리지 않으며, 비교적 간단한 연산을 수행하는 코드에 적합하다.
