---
layout: post
title: "[16챕터] IPv6"
subtitle: 자바의 정석 스터디 26회차
categories: Javatags: [java, 자바의정석, 네트워킹, IPv6]
---
## 앞서는 말
일단 이 책에는 IPv6에 관한 이론이나 메서드를 소개하지 않는다.
물론 지금도 개발을 할 때 의식적으로 많이 사용되고 있지는 않고 느리다거나 비용적인 문제 등 다양한 문제로 인해 지금은 사용되고 있지는 않는다.
그러나 IP 고갈과 다른 문제로 인해 머지않아 사용할 것이 분명하기에 공부를 해야 할 필요성이 느껴진다.
그렇기에 책에는 없지만 해당 내용을 어느 정도 갈무리하여 포스팅하고자 한다.

## IPv6 개요
기존에 쓰던 IPv4는 32비트의 주소를 사용하였다. 이렇게 말이다.
> 128.0.0.1

이런 식으로 각 자리마다 0~255의 숫자 중 하나를 가진다. 
즉, 8비트 블록을 4개씩 해서 32비트의 주소를 가지는 것이다.그렇다면 IPv6는 어떨까?
> 0000:0000:0000:0000:0000:0000:0000:0000

이런 식으로 표기가 된 주소이다. 
각 자리는 16비트씩 구분하며, 각 단위는 16진수로 변환되어 표기한다. 
즉, 10진수의 숫자가 아닌 16진수의 수로 표현한다.이렇게 해서 8블록이 있기에 총 128비트의 주소를 가지게 된다.
### 표현
보통은 앞의 64비트 구역을 네트워크 주소, 뒤의 64비트 구역은 랜카드 등에 할당하는 인터페이스 주소로 활용된다.
하지만, IPv4의 서브넷 마스크처럼 뒤에 '/'를 붙여 범위를 설정할 수 있다.다음의 예시를 통해서 알아보자.

> AAAA:BBBB:CCCC:DDDD::/64

밑에서 축약을 작성하긴 하겠지만 해당 주소는 제대로 적은 것이 맞다. 
뒤에는 0000:0000:0000:0000이 생략된 것이다.
해당 주소가 이렇게 적혀 있으면 64비트의 네트워크 주소를 갖는다는 것이다.
즉, AAAA:BBBB:CCCC:DDDD:: 부터 AAAA:BBBB:CCCC:DDDD:FFFF:FFFF:FFFF:FFFF 까지의 주소를 가지는 네트워크를 의미한다.

#### 축약
IPv6의 주소 표현은 전체를 다 작성하기에는 길다. 그래서 축약을 해서 표현하는 방법이 있다.두 가지의 경우가 존재한다.

1. 자리의 숫자가 0000인 경우이 경우에는 표기를 두 가지 방법으로 할 수 있다.
- 0 하나로 표현하기
- 연속된 0000 그룹이 존재하는 경우, 없애고 ':' 만으로 표기

예를 들어 2023:2022:0000:0000:0000:0000:2021:2020 이라는 주소가 존재할 경우, 표기할 수 있는 방법은 이렇게 된다.
> - 2023:2022:0:0:0:0:2021:2020
> - 2023:2022:0000::2021:2020
> - 2023:2022:0:::2021:2020
> - 2023:2022::2021:2020

이렇게 줄여 쓸 수 있다.
다만, 해당 규칙이 여러 번 나오는 경우(2023:2022:0000:0000:2021:0000:0000:0000 등),해당 축약법을 쓸 수 없다.그 이유는 축약법을 여러 번 쓸 경우, 의미가 불분명해지기 때문이다.

2. 자리의 숫자의 앞이 0인 경우이 경우에는 앞의 0을 축약하여 사용할 수 있다. 
2023::0913 과 같은 주소가 있으면 다음과 같이 표기가 가능하다.
> 2023::913

#### 특정 주소
- ::/128 : IP주소 미설정 상태의 발신 주소. 가상적으로만 사용.
- ::1/128 : 자기 자신을 가리키는 loopback 주소. IPv4에서 127.0.0.1 의 역할이라고 보면 된다.
- ::/96 : IPv4 호환 주소를 위해 사용되는 주소 공간.
- ::FFF0:0:0/96 : IPv4 매핑 주소를 위해 사용되는 주소 공간.
- FC00::/7 : IPv6 유니캐스트를 위한 주소 공간.
- FE80::/10 : 링크 로컬 주소를 위한 공간.
- FEC0::/10 : 사이트 로컬 주소를 위한 공간
- FF00::/8 : IPv6 멀티캐스트를 위한 주소 공간. IPv4의 브로드캐스트는 지원하지 않는다.

### 특징
1. 앞서 얘기했듯 128비트의 주소 길이를 가지고 있다. 즉, $2^{128}$의 개수를 가질 수 있다.
2. 기존의 IPv4는 64비트의 패킷 크기를 가지고 있다. 
그러나, IPv6는 특정한 옵션(점보 페이로드)을 이용하게 되면 특정 호스트 사이에 패킷 크기에 제한없이 통신이 가능하게 된다.
3. 보안에 있어서도 IPv4보다 강화되었다. 확장 헤더를 통해서 패킷 출처 인증 및 데이터 무결성 처리를 할 수 있게 되었다.

## 메서드
InetAddress라는 클래스가 있다.
해당 클래스는 책에도 나와있지만 IP address를 조작하고자 할 때 사용되는 클래스이다.
여기서 파생되는 클래스들이 바로
- Inet4Address
- Inet6Address

이고 그 중 Inet6Address가 IPv6를 조작하는 클래스이다.

몇 개를 써볼까 한다.

|메서드|설명|
|:--:|:--:|
|boolean equals(Object obj)|해당 Object를 특정한 Object(obj)와 비교한다.|
|byte[] getAddress()|IP 주소를 반환한다.|
|static Inet6Address getByAddress(String host, byte[] addr, int scope_id)|Inet6Address를 생성한다.|
|NetworkInterface getScopedInterface()|NetworkInterface는 네트워크에서 노드로 작동하는 디바이스에 접속하는 수단을 제공한다. 그러한 범위가 지정된 인터페이스를 제공한다.|

## 참고
https://ko.wikipedia.org/wiki/IPv6
https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/jsp/resources/vsix/addressSystem.jsp
https://docs.oracle.com/javase/8/docs/api/java/net/Inet6Address.html
